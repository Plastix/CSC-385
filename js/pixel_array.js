
// Constants for primary colors.
const COLOR_WHITE = vec3(1.0,1.0,1.0);
const COLOR_BLACK = vec3(0.0,0.0,0.0);
const COLOR_CYAN = vec3(0.0,1.0,1.0);
const COLOR_MAGENTA = vec3(1.0,0.0,1.0);
const COLOR_YELLOW = vec3(1.0,1.0,0.0);
const COLOR_RED = vec3(1.0,0.0,0.0);
const COLOR_GREEN = vec3(0.0,1.0,0.0);
const COLOR_BLUE = vec3(0.0,0.0,1.0);

/**
 * Class for storing and rendered 2D images, like the one generated by the ray tracer.
 * Uses WebGL and represents each square pixel using 2 triangles (so pretty
 * inefficient for high resolution images).  The code in this class is just a
 * refactored version of the starter code from Project 1.
 */
class PixelArray{

    /**
     *
     * @param pixel_width {integer} The width of this array in pixels.
     * @param pixel_height {integer} The height of this array in pixels.
     * @param glctxt {GLContext} The active GL context to render to.
     */
    constructor(pixel_width, pixel_height, glctxt){

        this.width = pixel_width;
        this.height = pixel_height;
        this.gl = glctxt;

        // Initialize buffers.
        this.pixel_colors = [];
        this.pixel_vert_buffer = this.gl.createBuffer();
        this.pixel_color_buffer = this.gl.createBuffer();

        // Initialize program and shader variable locations.
        this.program = initShaders(this.gl, "vertex-shader", "fragment-shader");
        this.vColor = this.gl.getAttribLocation(this.program, "vColor");
        this.vPosition = this.gl.getAttribLocation(this.program, "vPosition");
        this.mModelView = this.gl.getUniformLocation(this.program, "mModelView");

        // Fill buffers with pixel geometry.
        this.init_pixels();
    }

    /**
     * @returns {integer} The pixel width of this array.
     */
    get_width(){
        return this.width;
    }

    /**
     * @returns {integer} The pixel height of this array.
     */
    get_height(){
        return this.height;
    }

    /**
     * Sets a pixel to a color.
     *
     * @param x {integer} An integer from [0, width).
     * @param y {integer} An integer from [0, height).
     * @param color {vec3} Color to set pixel to.
     * @returns {number} Returns 0 if successful, -1 otherwise.
     */
    write_pixel(x, y, color){

        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {

            // Update color in our model.
            for (var i = 0; i < 6; i++)
                this.pixel_colors[6 * this.pixel_to_ix(x,y) + i] = color;

            // Update color in buffer.
            // Use bufferSubData to only make a partial update.
            // Should perform better then update the entire buffer.
            // Have to compute offset into buffer.
            // 6 vertices per square,
            // 3 color channels per vertex, and
            // 4 bytes per color channel.
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.pixel_color_buffer);
            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 6 * 3 * 4 * this.pixel_to_ix(x, y),
                                    flatten([color, color, color, color, color, color]));

            return 0;
        }
        return -1;

    }

    /**
     * Main rendering function.
     */
    render(){

        // Clear screen.
        this.gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Sets shader program
        this.gl.useProgram(this.program);

        // Construct Model View matrix to scale image from size width-by-height to
        // the canonical x = +-1, y =+-1 clipping volume.
        var mMV = mult(translate(-1,-1,0),scalem(2/this.width, 2/this.height, 1));
        this.gl.uniformMatrix4fv(this.mModelView, false, flatten(mMV));

        // Draw pixels
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.pixel_color_buffer);
        this.gl.vertexAttribPointer(this.vColor, 3, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.vColor);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.pixel_vert_buffer);
        this.gl.vertexAttribPointer(this.vPosition, 3, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.vPosition);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, this.pixel_colors.length);

        requestAnimFrame(render);


    }

    /**
     * Fills GL buffers with pixel vertex and color information.
     */
    // Initializes vertex and color buffer to draw the pixels.
    init_pixels(){

        this.pixel_colors = [];
        var pixel_verts = [];

        const SPACING = 0.0; // Can be set > 0 to see division between pixels.

        // Loop over all the pixel coordinates and create a white square.
        for (var y = 0; y < this.height; y++){
            for (var x = 0; x < this.width; x++){
                var lower_left = vec3(x + SPACING, y + SPACING, 0);
                var upper_right = vec3(x+1 - SPACING, y + 1 - SPACING, 0);
                create_rectangle(pixel_verts, this.pixel_colors, lower_left, upper_right, COLOR_BLACK);
            }
        }


        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.pixel_color_buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, flatten(this.pixel_colors), this.gl.STATIC_DRAW);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.pixel_vert_buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, flatten(pixel_verts), gl.STATIC_DRAW);

    }

    /**
     * Erase all pixels.
     */
    clear_pixels(){

        // Sets all pixel_colors to white.
        for (var i = 0; i < this.pixel_colors.length; i++)
            this.pixel_colors[i] = COLOR_BLACK;

        // Reset the entire color buffer.
        gl.bindBuffer(gl.ARRAY_BUFFER, this.pixel_color_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(this.pixel_colors), gl.STATIC_DRAW);


    }

    /**
     * Converts integer pixel coordinates to index in flatten array.
     * @param x {integer} x coord
     * @param y {integer} y coord
     * @returns {integer} flat array index.
     */
    //
    pixel_to_ix(x, y){
        return (y*this.width + x);
    }


}


// Extends arrays verts and colors with a colored rectangle
// with specified corners.
function create_rectangle(verts, colors, lower_left, upper_right, color) {

    // Draws as 2 triangles.
    colors.push(color);
    verts.push(lower_left);
    colors.push(color);
    verts.push(upper_right);
    colors.push(color);
    verts.push(vec3(lower_left[0],upper_right[1],0));

    colors.push(color);
    verts.push(lower_left);
    colors.push(color);
    verts.push(upper_right);
    colors.push(color);
    verts.push(vec3(upper_right[0],lower_left[1],0));

}


